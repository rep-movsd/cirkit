/** @jsx h */

type ComponentTrait = 'list'|'set';
type Dict = { [key: string]: any };
type IndexedItem = { index: number, item: any };

///////////////////////////////////////////////////////////////////////////////
// region JSX handling

// Helper types
type StyleDict = Partial<CSSStyleDeclaration>;
type HTMLTag = keyof HTMLElementTagNameMap;

type Primitive = string | number | boolean;

type HTMLAttributeProps<T> = {
  [K in keyof T as T[K] extends Primitive ? K : never]?: T[K];
};

type NativeHTMLPropsFor<Tag extends HTMLTag> = HTMLAttributeProps<HTMLElementTagNameMap[Tag]>;


// 'click' | 'mousedown' | 'keydown' | ...
type DOMEventName = keyof HTMLElementEventMap;

// 'item.click' | 'item.mousedown' | 'item.keydown' |
type ItemEventName = `item.${DOMEventName}`;

type ComponentEvent = DOMEventName | ItemEventName


type ComponentProps<BindElement = any, Tag extends HTMLTag = any> = {
  /*
  The `tag` property specifies which HTML element to use for the component.

  You can specify it as:
    - A string with the HTML tag name

        `tag='elem'`

    - An element as a component property

        `tag={<elem ... />}`

    - As a child in the JSX

        `<tag><elem ... /></tag>`
  */
  elem?: Tag;

  /* `class` specifies the CSS class(es) to apply to the component.*/
  class?: string;

  /* `trait` specifies if this component is a collection container. */
  trait?: ComponentTrait;

  /* `bind` specifies `List<BindElement>` object that is tied to this collection component.

  The children of the collection component will be automatically synchronized with the items in the list when the list is modified.
  * */
  bind?: List<BindElement>;

  /*
  `span` specifies the `flex-grow` proportion for the component within its Hbox or VBox parent.

  For example:
    ```
    <box class='HBox'>
      <box1 span={1} />
      <box2 span={2} />
      <box3 span={4} />
    </box>
    ```
  This will set the proportions of the three boxes to `1:2:4`.

  If you need to override the dimension via styles, set this to 0.
  */
  span?: number;

  /* The **style** property is simply the CSS style */
  style?: StyleDict;

  /*
  The **selector** property specifies the function that is called when an item in a collection component is selected.

  The `List<BindElement>` bound to the component has a slot **doSelect**, which will call the selector function with the selected item and selection state.

  Note that any current selection will be deselected, before the new one is selected - meaning the selector is called twice - once with `false` and then with `true`.

  * *Multiple selection is not supported yet*
  */
  selector?: DOMPropUpdaterFactory;

  /*
  `signals` specifies the DOM events that will emit signals when they occur.
  The emitted signal name is the path to the component, followed by the event name.

  Apart from the standard DOM events, you can also specify item events, which are prefixed with `item.`

  Item event signals will have a name of the form `<path>.item.<event>` where <path> is the path to the collection component and <event> is the event name.
  The index of the child item that sent the event is passed as the signal data.

  For example, if the collection component is `todos` and the event is `click`, then the signal name will be `todos.item.click`.
  * */
  signals?: ComponentEvent[];

  [key: string]: any;
};


type GenericUpdater = {[elemName: string]: DOMPropUpdaterFactory}

type ItemComponentProps =
{
  tag?: HTMLTag,
  setter?: GenericUpdater;
  template?: ComponentProps;
}

export type Updater<T> = { [K in keyof T]?: DOMPropUpdaterFactory; };

declare namespace h.JSX
{
  interface IntrinsicElements
  {
    'item-template': ItemComponentProps;
    [elemName: string]: ComponentProps;
  }
}

type Component =
  {'item-template'?: ItemComponentProps} &
  {[elemName: string]: ComponentProps}


//const HTMLTags = Object.keys({[key in keyof HTMLElementTagNameMap]: true}) as HTMLTag[];

// Our custom hyperscript function.
// It builds a nested dictionary of components and their properties
// component names are left unchanged, so that they can be used as tags
// property names get an _ prefix

function h(sTag: string, dctProps: ComponentProps, ...arrChildren: Component[]): any
{
  //console.log(sTag);
  //console.log('props', JSON.stringify(dctProps));
  //console.log('children', JSON.stringify(arrChildren));
  //console.log('-----------------');

  // Process children into an object.
  let dctChildObject: Component = {};
  const processChild = (child: any) =>
  {
    // Skip null values
    if(child !== null)
    {
      // Plain strings become _label which will be rendered as static text
      if(typeof child === 'string')
      {
        if(!dctProps) dctProps = {};
        dctProps.label = child;
      }
      else
      {
        const sChildKey = Object.keys(child)[0];
        dctChildObject[sChildKey] = child[sChildKey];
      }
    }
  };

  // A list collection element will have a template property used to create the children
  const isCollection = !!dctProps?.trait;
  if(isCollection)
  {
    const itemTemplateNode = arrChildren[0];
    const keys = Object.keys(itemTemplateNode);
    if(keys.length !== 1 || keys[0] !== 'item-template')
    {
      throw new Error('Collection component must have a single item-template child');
    }
    dctProps.template = Object.values(arrChildren[0])[0];
  }
  else
  {
    // Iterate over children.
    for(const child of arrChildren)
    {
      // Recursively process children arrays
      if(Array.isArray(child))
        child.forEach(processChild);
      else
        processChild(child);
    }
  }

  // Merge remaining props with the children object, but add _ prefix to the property names
  const dctRet: any = {...dctChildObject};
  if(dctProps)
  {
    for(const [key, value] of Object.entries(dctProps))
    {
      dctRet[`_${key}`] = value;
    }
  }
  return {[sTag]: {...dctRet}};
}

// endregion JSX handling
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// region Signal and Slot handling


// Signals names are typically dotted paths For example: 'app.colors.item.click'
type SignalName = string;

// Slots have an arbitrary data object and a signal name
// The data is kept as the first parameter, so that any function with one param can also be a slot
type Slot = (data: any, signal: SignalName) => void;

// Connection switchboard for signals to slots
const SwitchBoard: { [signal: SignalName]: Slot[] } = {};

type Signal = { signal: SignalName, data: any };
const SignalQueue: Signal[] = [];

// Connect a signal to a slot or other signal
const wire = (signal: SignalName, target: Slot|string) =>
{
  // If the target is a function, otherwise its another signal, so create a function that emits the signal.
  let slot: Slot = (typeof target === 'function') ? target : (data, sig) => emit(target, data);

  // Append the slot to the signal's slot list.
  addToDictArray(SwitchBoard, signal, slot);
};

// When a signal is emitted, add it to the queue
// The dispatch is run only if this is the first signal that came in
// If signal handling causes more signals to be emitted, they will be added to the queue and be picked up
// by the next loop of the dispatch code.
const emit = (signal: SignalName, data: any = null) =>
{
  SignalQueue.push({signal, data});
  if(SignalQueue.length === 1) dispatch();
};

// Dispatch the signals in the queue
const dispatch = () =>
{
  // Keep looping till the queue is empty (slots may emit more signals to get queued)
  while(SignalQueue.length)
  {
    // Grab the first signal call all slots
    // We dont remove it from the queue yet, so that any other signals emitted by the slots are queued up
    const sig: Signal = SignalQueue[0];
    const slots = SwitchBoard[sig.signal] || [];
    for(const slot of slots)
    {
      slot(sig.data, sig.signal);
    }

    // Pop the processed signal
    SignalQueue.shift();
    //console.log(sig);
  }
};

// endregion Signal and Slot handling
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// region DOM handling


// Map type for the parsed component tree with prefix _ on all properties
type ComponentDOMDict =
  {[Key in keyof ComponentProps as `_${Key}`]: ComponentProps[Key]} &
  {_template?: ItemComponentProps, refs?: any, ref? : HTMLElement, };

type HTMLComponent = HTMLElement & {'_trait'?: ComponentTrait, '_comp'?: Component};

// Finds the index of a collection element, given any child in it
function getIndex(elem: any): number
{
  // First find the element which maps to the collection component by walking up the tree
  // This element will have the _comp property
  // Also keep track of the the element which was the direct child of the collection component
  let elemComp = elem, elemChild;
  while(elemComp && !elemComp._comp)
  {
    elemChild = elemComp;
    elemComp = elemComp.parentElement;
  }

  // Now elemChild is the top level ref for the item and elemComp is the collection component
  // Lookup the index of elemChild in the _refs array of the collection component
  // unlike refs, _refs has a flat array of all the top level children of the component
  return firstDictVal(elemComp._comp)._refs.indexOf(elemChild);
}

// Attaches event handlers to the element that emit signals
// We can prefix signal names with 'item.' to indicate that the signal is on the item
function attachSignalHandlers(dctProps: ComponentDOMDict, element: HTMLElement, path: string)
{
  if(dctProps?._signals)
  {
    for(const signal of dctProps._signals)
    {
      // Item signal handlers are attached to the parent rather than to each item
      const sSignalName = path + '.' + signal;
      if(signal.startsWith('item.'))
      {
        // Item signals will send their index as the data
        element.addEventListener
        (
          // Remove the item. prefix from the signal name
          signal.split('.')[1],

          // This event handler will be called twice - once for the collection element and once for the item
          // Only send signal if the event target is the parent collection element
          evt => (evt.target !== element) && emit(sSignalName, getIndex(evt.target)),
        );
      }
      else
      {
        element.addEventListener(signal, evt => emit(sSignalName, evt));
      }
    }
  }
}

// Set the properties for an element when planting
function handleProps(comp: Component, dctProps: ComponentDOMDict, elem: HTMLComponent, sPath: string)
{
  if(dctProps?._class) elem.className = dctProps._class;

  // Span is the flexGrow, can be 0 to override with fixed size
  if(dctProps?._span) elem.style.flexGrow = String(dctProps._span);

  // We need to save the trait and component properties into the HTML element itself
  if(dctProps?._trait)
  {
    elem._trait = dctProps._trait;
    elem._comp = comp;
  }

  // If label exists, set the innerText
  if(dctProps?._label) elem.innerText = dctProps._label;

  // Signals and data binding
  if(dctProps._signals) attachSignalHandlers(dctProps, elem, sPath);
  if(dctProps._bind) bindList(dctProps, dctProps._bind);

  // copy all the style properties into the element style
  if(dctProps._style)
  {
    for(const [prop, value] of Object.entries(dctProps._style))
    {
      (elem.style as any)[prop] = value;
    }
  }

  // Save the ref in the component object
  dctProps._ref = elem;
}

function createTagElem(tag: string | Dict)
{
  // If it is a string, create the element with that tag
  if(typeof tag === 'string')
  {
    return document.createElement(tag);
  }

  // If its an object, it could be a component or an intrinsic element
  // Get the first key in the object and try creating it
  const tagName = Object.keys(tag)[0];
  let elem = document.createElement(tagName);
  if(elem.toString() == "[object HTMLUnknownElement]")
  {
    throw new Error(`Unknown HTML element ${tagName}`);
  }
  // Iterate over the tag properties and assign them to the element
  for(let i = 1; i < Object.keys(tag).length; i++)
  {
    const key = Object.keys(tag)[i];
    (elem as any)[key] = tag[key];
  }
  return elem;
}


function plantDOMTree(dct: Component, elemSite: HTMLElement, sPath: string = '', elemInsertBefore = null): Component
{
  for(const sKey in dct)
  {
    const dctChildren: ComponentDOMDict = dct[sKey];
    let elem: HTMLElement = createTagElem(dctChildren._tag || 'div');

    // Save the path
    sPath = sPath ? (elemSite.dataset.path + '.' + sKey) : sKey;
    elem.dataset.path = sPath;
    handleProps(dct, dctChildren, elem, sPath);

    // Recursively process children
    for(const name in dctChildren)
    {
      const child: any = (dctChildren as Dict)[name];

      // Skip special props
      if(name[0] !== '_')
      {
        // If the child is an object, and not a special property, then it is a child component
        if(typeof child === "object")
        {
          if(Array.isArray(child))
            child.forEach(item => plantDOMTree({[name]: item}, elem, sPath));
          else
            plantDOMTree({[name]: child}, elem, sPath);
        }
        else if(typeof child === "string")
        {
          elem.innerText = child;
        }
      }
    }

    // Attach the element to the site
    elemSite.insertBefore(elem, elemInsertBefore);
  }

  // Return the first element of the tree (used to save the top level element as the application object)
  return firstDictVal(dct);
}

// Given a component and a dotted property path, return the component ref for the elem at that path and the prop name
// For example getPathRef(app, 'todos.box.boxColor.color') will return [todos.box.boxColor.ref, 'color']
export function getPropPathRef(comp: any, path: string): any
{
  // Split the path into an array
  const arrPath: string[] = path.split('.');
  let target = comp;

  // Iterate over the all but the last of the dotted path, walking down the component tree
  for(let i = 0; i < arrPath.length - 1; i++)
  {
    const key = arrPath[i];
    target = target[key];
  }

  // The prop name is the last element of the path
  return [target, arrPath.pop()];
}


type DOMPropUpdater = (target: HTMLElement|Component, propName: string, value: any) => void;
type DOMPropUpdaterFactory = (comp: any, value: any) => void;

// Helper to make updater functions for style attribute, classname or property
const makeUpdater = ( prop: string, apply: DOMPropUpdater): DOMPropUpdaterFactory => {
  return (comp: any, value: string|number) =>
  {
    const [target, propName] = getPropPathRef(comp, prop);
    apply(firstDictVal(target)?.ref || target.ref || target, propName, value);
  };
};

// Updater functions for setting properties, styles, attributes and classnames for components
const setProp = (prop: string) => makeUpdater(prop, (target, propName, value) => (target as any)[propName] = value);
const setStyle = (prop: string) => makeUpdater(prop, (target, propName, value) => (target.style as any)[propName] = value);
const setClass = (prop: string) => makeUpdater(prop, (target, propName, value) => target.classList.toggle(propName, value));
const setAttr = (prop: string) => makeUpdater(prop,  (target, propName, value: string) => (target as HTMLElement).setAttribute(propName, value));


// endregion DOM handling
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// region Data Binding

// Abstraction of an array like collection that emits signals on add, set, delete and can be selected
class List<T>
{
  // Store data as an array
  private _data: T[] = [];

  // Name the list the same as the component that uses it - for example data.todos = new List<TodoItem>('todos')
  private readonly _name: string;

  // Currently selected index
  private _selected: number = -1;

  // place holder for slots - TODO: Why not make all the methods slots
  public slots: any;

  emitSelCurrent = (b: boolean) => (this._selected >= 0 &&  emit(`${this._name}.sel`, {index: this._selected, selected: b}));

  constructor(name: string)
  {
    this._name = name;

    this.slots = {
      // Single select slot
      doSelect: (index: number) =>
      {
        index = index ?? -1;
        if(this._selected !== index)
        {
          // Emit a signal to deselect the current selection, then emit a signal to select the new index if valid
          this.emitSelCurrent(false);
          this._selected = index;
          this.emitSelCurrent(true);
        }
      }
    }
  }

  get name(): string {return this._name;}

  get items(): T[] {return this._data;}

  get selectedItem(): T
  {
    return this._data[this._selected];
  }

  get selectedIdx(): number
  {
    return this._selected;
  }

  public add(item: T, idxBefore: any = null): void
  {
    // Insert at index idx or end if not specified
    idxBefore = idxBefore ?? -1;
    const index = idxBefore >= 0 ? idxBefore : this._data.length;
    this._data.splice(index, 0, item);
    const ii: IndexedItem = {item, index};

    // Deselect the current selection if any and reselect later
    this.emitSelCurrent(false);
    emit(`${this._name}.+`, ii);
    this.emitSelCurrent(true);
  }

  public set(index: number, item: T): void
  {
    this._data[index] = item;
    emit(`${this._name}.*`, item);
  }

  public del(index: number): void
  {
    this._data.splice(index, 1);
    emit(`${this._name}.-`, index);
  }

  public addAll(items: T[]): void
  {
    // TODO
  }
}

// Connects the collection component to the list
function bindList(comp: ComponentDOMDict, list: List<any>)
{
  console.assert(comp._trait != null, 'Collection components must have a trait property');

  const name = list.name;
  const template = comp._template as ItemComponentProps;

  // Components have tag as a JSX parsed Object
  const isComp = typeof template.tag == 'object';

  // Makes a tree of components with only the ref property
  // For e.g. {box: {ref: <div>}, boxColor: {ref: <div>}}
  const getChildRefs = (dct: any) =>
  {
    const refs: Dict = {};
    for(const key of Object.keys(dct))
    {
      const child = dct[key];
      if(child.ref) refs[key] = {ref: child.ref};
      if(child.tag || child.class) Object.assign(refs[key], getChildRefs(child));
    }
    return refs;
  }

  // Applies the updater functions to the element for each key in data
  const setData = (data: IndexedItem, elem: any) =>
  {
    if(template.setter)
    {
      for(const key of Object.keys(data.item))
      {
        template.setter[key](elem.refs[data.index], data.item[key]);
      }
    }
  }

  const selectIfValid = (b: boolean) =>
  {
    const idxSelected = comp._bind?.selectedIdx ?? -1;
    if(idxSelected >= 0 && idxSelected < comp._refs.length)
    {
      emit(`${name}.sel`, {index: idxSelected, selected: b});
    }
  }


  // Add an element to the list
  const addElem = (data: IndexedItem) =>
  {
    // Save the ref in the refs array at the same index
    if(!comp.refs) comp.refs = [];

    // Get the template and make the DOM element, set all properties, add to the parent, save ref
    let elem: HTMLElement;
    if(typeof template.tag == 'string')
    {
      elem = document.createElement(template.tag)
    }
    else
    {
      throw new Error('Template tag must be a string');
    }

    // If there was anything selected, deselect it
    selectIfValid(false);

    // Insert the element at the correct index amd its ref
    const index = data.index;
    const ref = comp.refs[index];
    comp.ref?.insertBefore(elem, ref);
    comp.refs.splice(index, 0, elem);
    setData(data, comp);

    // Duplicate the refs array as _refs  to match the _refs used for component collections
    comp._refs = comp.refs;

    // If there was anything selected, reselect it
    selectIfValid(true);
  }

  /*
  const addComp = (data: IndexedItem) =>
  {
    // We need to store refs of the the top level children of this component in an array _refs
    // We also need to store the nested refs so the user code can access them  under the refs array
    if(!comp._refs) comp._refs = [];
    if(!comp.refs) comp.refs = [];

    // If there was anything selected, deselect it
    selectIfValid(false);

    // Get the top level ref of the item at the insert index
    const index = data.index;
    const ref = comp._refs[index];

    // Plant the dom subtree, then save the refs of all children in a tree
    const tag = {...(template.tag as ComponentProps)};
    const compMain = plantDOMTree(tag, comp.ref, comp.ref.dataset.path, ref);
    const childRefs = getChildRefs(template.tag);

    // Add the nested refs and the flat refs to respective arrays
    comp.refs.splice(index, 0, childRefs);
    comp._refs.splice(index, 0, compMain.ref);

    setData(data, comp);

    // If there was anything selected, reselect it
    selectIfValid(true);
  }*/


  const delElem = (index: number) =>
  {
    const elem = comp.refs[index];
    comp.ref?.removeChild(elem);
    comp.refs.splice(index, 1);
  }

  // Connect the list signals to corresponding ones here
  //wire(`${name}.+`, isComp? addComp: addElem);
  //wire(`${name}.-`, delElem);

  const selector = comp._selector;
  if(selector)
  {
    wire(`${name}.sel`, item => (selector as DOMPropUpdaterFactory)(comp.refs[item.index], item.selected));
  }
}

// endregion Data Binding
///////////////////////////////////////////////////////////////////////////////



export {Dict, Component, IndexedItem, List};
export {wire, emit, SignalName, Slot};
export {h, plantDOMTree, setProp, setStyle, setClass};
